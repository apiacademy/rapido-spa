import Ember from "ember";

export default Ember.ObjectController.extend( {    
    needs: ['project','resources'],
    projectController: Ember.computed.alias('controllers.project'),
    statesController: Ember.computed.alias('controllers.states-editor'),

    initialize: function() {
        //this.set('activeMethod', 
        console.log('initialize');
        console.log(this.get('model'));

        this.set('isDirty', false);
    }.observes('model'),


	dirtyResponses: {},
	isDirty: false,

    /** For TypeAhead: **/
    resourceNames: function() {
        var resources = this.get('resourceController').model.content;
        var nameList = [];
        for( var i = 0; i < resources.length; i++ ) {
            nameList.push(resources[i]);
        }
        return nameList;
    },
    suggestions: function() {
        var suggestionList = [];

        var projectVocabulary = this.get('projectController').model.get('simpleVocabulary');
        var projectVocabList = { meta: 'vocabulary', words: []};
        for( var i = 0; i < projectVocabulary.length; i++ ) {
            projectVocabList.words.push(projectVocabulary[i]);
        }

        suggestionList.push(projectVocabList);
        return suggestionList;

    }.property('controller.project.model'),

    /** Method Checklist Properties **/
	isGETEnabled: false,
	isPUTEnabled: false,
	isPATCHEnabled: false,
	isPOSTEnabled: false,
	isDELETEEnabled: false,	
    activeMethod: '',
    /** DEBUG
    blah: function() {
        console.log('active method has been updated!');
        console.log(this.activeMethod);
        this.set('debugging', this.activeMethod);
    }.observes('activeMethod'),
    **/
	methodsUpdated: function() {
		console.log('updated');
		Ember.run.once(this, 'processMethodUpdates');
	}.observes('isGETEnabled','isPUTEnabled','isPATCHEnabled','isPOSTEnabled','isDELETEEnabled'),
	processMethodUpdates: function() {
        console.log('processMethodUpdates');
		this.set('isDirty',true);
		var newResponseStates = [];
		var newMethods = [];
		if( this.isGETEnabled ) { newResponseStates.push('GET'); newMethods.push('GET'); }
		if( this.isPUTEnabled ) { newResponseStates.push('PUT'); newMethods.push('PUT'); }
		if( this.isPATCHEnabled ) { newResponseStates.push('PATCH'); newMethods.push('PATCH'); }
		if( this.isPOSTEnabled ) { newResponseStates.push('POST'); newMethods.push('POST'); }
		if( this.isDELETEEnabled ) { newResponseStates.push('DELETE'); newMethods.push('DELETE'); }
		
		this.set('responseStates',newResponseStates);
		this.get('content').set('methods',newMethods);
	},
    responseStates: [],

    body: '',
    debugging: 'testing.',

    responseBody: function() {
        console.log('responseBody called...');
		var activeMethod = this.get('activeMethod');

		// First check for a dirty response		
		if( this.dirtyResponses[activeMethod] ) {
            console.log('found a dirty response for ' + activeMethod);
            return this.dirtyResponses[activeMethod];
        }

        // If there is not a dirty response available, find and render the resource's original response
		var responses =  this.get('model').get('responses');		
        console.log(responses);
		for( var i = 0; i < responses.length; i++ ) {
			if( responses[i].name === activeMethod ) {
                console.log('original response found.');
                console.log('returning ' + responses[i].body);
                return responses[i].body; 
            }
		}

		// A response state was not found, so we will create it.  When saving the resource object we can throw away blank responses
        console.log('no response found.');
        console.log(activeMethod);
        console.log(responses);
		responses.push({name: activeMethod, body: ''});
		return '';				
	}.property('activeMethod'),

	aceMode: 'ace/mode/json',

	actions: {
		responseUpdated: function(newValue) {
            console.log('responseUpdated');
			this.set('isDirty', true);
			var activeMethod = this.get('activeMethod');
			var dirtyResponses = this.get('dirtyResponses');
			dirtyResponses[activeMethod] = newValue;
		},
        saveResponse: function() {
            var resource = this.get('model');
            var responses = resource.get('responses');

            //update the reponse bodies
            var _responses = [];

            // Check for 'response states' that have been enabled (GET,PUT,POST,DELETE,PATCH)
            var enabledMethods = this.get('responseStates');
            for( var i = 0; i < enabledMethods.length; i++ ) {
                var body = this.get('dirtyResponses')[enabledMethods[i]];
                if( !body ) {
                    // This type of response was not edited, so copy the original data
                    for( var j = 0; j < responses.length; j++ ) {
						if( responses[j].name === enabledMethods[i] ) {
                            body = [j].body;
                        }
					}

                    _responses.push({
                        name: enabledMethods[i],
                        body: body
                    });
                }
            }

            resource.set('responses', _responses);
            console.log(resource);
            //resource.save();
        }
	}
});
